use warnings;
use strict;
use Getopt::Long;

# Karsten Hokamp, Trinity College Dublin, Dec 2019
#
# part 3 of a multi-part analysis that tries to detect chimeric RNA sequences
# here we focus on a subset of annotated features (sRNAs) and create output files for each of them
# the output contains all reads where either the start or end maps to the according sRNA
# and the feature that is either overlapped by the other start/end or lies nearby its mapping position

my $annotation_file = '';

&GetOptions(
    'annotations=s' => \$annotation_file,
    );

my %loc = ();
my %sRNA = ();

open (IN, $annotation_file)
    or die;

#NZ_CP008706.1   RefSeq  gene    92960   93224   .       +       .       ID=sRNA1
#NZ_CP008706.1   RefSeq  gene    3810843 3810999 .       +       .       ID=sRNA2

while (<IN>) {
    next if (/^#/);
    chomp;
    s/\cM//;
    my @h = split /\t/, $_;
    my $start = $h[3];
    my $end = $h[4];
    my $strand = $h[6];
    my $id = $h[-1];
    $id =~ s/ID=//;
#    next unless ($id =~ /ABUW_RS11280/);
    if ($id =~ /^sRNA.+/) {
	$id =~ s/\;.+//;
	foreach ($start..$end) {
	    $sRNA{$strand}{$_} = $id;
	}
    } else {
	foreach ($start..$end) {
	    $loc{$strand}{$_} = $id;
	}	
    }
}
close IN;


# read in data generated by chimera_start_end_mapped_distances.pl
# which includes mapping information from start/end pieces of originally unmapped reads:
my $header = <>;
chomp $header;
$header =~ s/\cM//;
$header .= "\tparent\tproduct";

my %done = ();

while (<>) {
    chomp;
    s/\cM//;
    my ($id, $sample, $start, $start_strand, $feature1, $end, $end_strand, $feature2, $distance, $start_seq, $end_seq) = split /\t/, $_;
    my $sRNA = '';
    my $parent = '';
    my $product = '';
    if (defined $sRNA{$start_strand}{$start}) {
	$sRNA = $sRNA{$start_strand}{$start};
	$feature1 = $sRNA{$start_strand}{$start};
	if (defined $loc{$end_strand}{$end}) {
	    $feature2 = $loc{$end_strand}{$end};
	} else {
	    $feature2 = &find_closest($end_strand, $end);
	}
	($parent, $product) = &parse($feature2);
    } elsif (defined $sRNA{$end_strand}{$end}) {
	$sRNA = $sRNA{$end_strand}{$end};
        $feature2 = $sRNA{$end_strand}{$end};
        if (defined $loc{$start_strand}{$start}) {
            $feature1 = $loc{$start_strand}{$start};
	} else {
	    $feature1 = &find_closest($start_strand, $start);
	}
	($parent, $product) = &parse($feature1);
    }
    if ($sRNA ne '') {
#	and $sRNA eq 'sRNA21') {
	my $file = "sRNA_detection_$sRNA.xls";
	unless (-s $file) {
	    open (OUT, ">$file")
		or die;
	    print OUT "$header\n";
	    close OUT;
	} 
	my $out = "".(join "\t", ($id, $sample, $start, $start_strand, $feature1, $end, $end_strand, $feature2, $distance, $start_seq, $end_seq, $parent, $product))."\n";
	next if (defined $done{$out});
	$done{$out}++;
	open (OUT, ">>$file")
	    or die;	
	print OUT $out;
	close OUT;
    }
}


sub find_closest {

    # a read has been mapped to a position which does not overlap with an annotated feature
    # find the closest annotated feature by moving in both directions until an overlap is found
    # choose the one with the smallest difference (or the one upstream in case of a tie):
    
    my $strand = shift;
    my $pos = shift;
    my $up = '';
    my $down = '';
    my $add = 0;
    until ($up) {
	$add++;
	if ($add > 1000000) {
	    warn "More than a million bp from $pos away!\n";
	    last;
	}
	if (defined $loc{$strand}{$pos+$add}) {
	    $up = $add;
	}
    }
    $add = 0;
    until ($down) {
        $add++;
	if ($pos-$add < 0) {
	    warn "Reached below 0 from $pos!\n";
	    last;
	}
        if (defined $loc{$strand}{$pos-$add}) { 
            $down = $add;
        }
    }
    
    if ($down eq '') {
	return ($loc{$strand}{$pos+$up});
    } elsif ($up eq '') {
	return ($loc{$strand}{$pos-$down});
    }

    if ($down < $up) {
	return ($loc{$strand}{$pos-$down});
    } else {
	return ($loc{$strand}{$pos+$up});
    }
}

    
sub parse {
    # extract relevant information from the annotation data, 
    # particularly 'Parent' and 'product' fields
    my $string = shift;
    my $pa = '';
    my $pr = '';
    if ($string =~ /Parent=(.+?);/) {
	$pa = $1;
    }
    if ($string =~ /product=(.+?);/) {
	$pr = $1;
    }
    return ($pa, $pr);
}
